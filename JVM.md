# JVM

## 1. Java虚拟机是什么？

虚拟机是一种抽象化的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java虚拟机屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。

## 2. 机器码和字节码

**机器码**：

计算机直接使用的程序语言，其语句就是机器指令码，机器指令码是用于指挥计算机应做的操作和操作数地址的一组二进制数

**字节码**：

Java之所以可以“一次编译，到处运行”，一是因为JVM针对各种操作系统、平台都进行了定制，二是因为无论在什么平台，都可以编译生成固定格式的字节码（.class文件）供JVM使用。因此，也可以看出字节码对于Java生态的重要性。之所以被称之为字节码，是因为字节码文件由十六进制值组成，而JVM以两个十六进制值为一组，即以字节为单位进行读取

## 3. JVM运行时数据分区

1.线程共享区：堆、方法区

2.线程独占区：程序计数器、虚拟机栈、本地方法栈

3：**程序计数器**：当前线程所执行的Java字节码的行号   

**虚拟机栈**：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表（ 存放了各种基本数据类型 、对象引用）、操作数栈、动态链接、方法出口。如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。   **堆**：主要存放对象实例，所以Java堆中还可以细分为：新生代和老年代；新生代可以有Eden空间、From Survivor空间、To Survivor空间   

**方法区**：存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，即存放静态文件，如Java类、方法等   

1.6 运行时常量池放在方法区中，1.7在堆中，1.8在元空间中

## 4. JVM类加载机制

**1.加载** 通过类的全限定名获得这个类的二进制字节流，把二进制字节流按照方法区的数据存储结构存储在方法区中，在内存中生成一个代表这个类的class对象，作为方法区这个类的数据访问入口

**2.验证** 文件格式验证，验证二进制字节流是否符合class文件格式规范，如是否以魔数cafebaby开头，元数据验证，验证字节码描述的语义是否符合Java语言规范，如这个类是否实现了接口中的所有方法，字节码验证，验证程序语义是符合规范的，符号引用验证

**3.准备** 为类变量（static修饰的变量）设置初始值0，但是实例变量不会设，会跟随对象一起进入堆中。Final修饰的会被直接设置所定义的值

**4.解析** 把常量池中的符号引用（符号引用引用的目标并不一定已经加载到内存中）替换为直接引用（直接引用可以是直接指向目标的指针、相对偏移量，直接引用引用的目标必定已经在内存中存在）

**5初始化** 初始化阶段是执行类构造器<clinit>（）方法的过程，类的构造方法用于对类的成员变量进行初始化，程序是默认添加一个无参构造的，如果有需要可以重载这个方法，可以在创建对象的时候传入参数对对象初始化。子类继承父类，子类必须在自己的构造方法第一行用super()显式的调用父类的构造方法，如果父类只有无参构造方法，且不打算重写子类的构造方法，为节省代码量，子类构造方法可以不写，但是实际上是已经写了，系统默认会在子类的无参构造方法中的第一行加上父类的无参构造方法

## 5. 类的初始化时机

![Image text](https://github.com/Arzinia/MyProject/blob/master/images/%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E6%9C%BA.png)

## 6. 双亲委派机制

启动类加载器（加载JDK的/lib目录下的类）、扩展类加载器extetion（加载JDK的/lib/ext目录下的类）、应用程序类加载器（程序classpath下的类）、自定义加载器

如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载

## 7. 如何破坏双亲委派机制

1.继承ClassLoader，重写loadclass方法，将需要特殊对待的类自己先处理，非处理范围的类调用super方法即可

2.利用线程上下文类加载器，比如加载JDBC驱动com.mysql.jdbc.Driver的时候，肯定不在jdk/lib下，所以肯定是无法加载mysql中的这个类的。父级加载器无法加载子级类加载器路径中的类。在启动类加载器中Thread.setContextClassLoaser()方法设置应用程序类加载器，然后通过它去加载就可以了。

## 8. GC时机

当Eden区中没有足够的空间进行分配时，虚拟机将发起一次MinorGC（复制算法）；老年代内存满、代码中显式调用System.gc()的时候会触发一次Full GC。GC进行时， Eden区所有存活的对象都会被复制到To Survivor区，而在From Survivor区，仍存活的对象会根据它的年龄值决定去向，年纪值达到年龄阈值的对象会被移动到老年代中（默认为15），没有达到阈值的会被移动到To Survivor区。接着From Survivor区和To Survivor区交换角色。GC时如果To Survivor区没有足够的空间存放上一次新生代收集下来的存活对象时，需要依赖老年代进行分配担保，将这些对象存放在老年代中

## 9. JVM内存分配优化策略

1.对象优先在Eden分配

2.大对象直接进入老年代避免在Eden区及两个Survivor区之间发生大量的内存复制

3.长期存活的对象将进入老年代（默认15）

4.动态对象年龄判定：如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代

5.空间分配担保：出现大量对象在Minor GC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要年代进行分配担保，把Survivor无法容纳的对象直接进入老年代

## 10. 如何判断对象已经死亡？

引用计数法（不用）：存在引用计数器+1，不引用就-1，但是存在循环引用的问题，所以基本不用

可达性分析: 这个算法的基本思路就是通过一系列的称为“GC Roots”的对象（虚拟机栈（栈中的局部变量表）中引用的对象/方法区中类静态属性引用的对象/本地方法区中常量引用的对象/本地方法栈中native方法引用的对象）作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的
真正宣告一点对象死亡，至少要经历两次标记的过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，第一次标记之后如果有必要执行finalize()方法就去执行，如果在finalize()重新获得引用，则对象被救活，此后会进行第二次标记，第二次标记后不会再执行finalize()，接着被回收。finalize()的作用：把对象放入F-Queue队列中

## 11. 引用的类型

强引用（Strong Reference）：只要强引用还在，被引用的对象就永远不会被回收。如内存不足，JVM会抛出OOM错误也不会回收object指向的对象

软引用（Soft Reference）：描述还有用但是非必须的对象（比如缓存），在系统将要发生内存溢出之前，将会把这些对象列进回收范围进行二次回收，如果这次回收还是没有足够的内存，则会抛出内存溢出异常

弱引用（Weak Reference）：描述还有用但是非必须的对象，但是比软引用更弱，只能生存到下次垃圾回收发生之前，当垃圾收集器工作时，会回收掉这部分对象，无论内存是否足够

虚引用（Phantom Reference）：没有什么用，为一个对象设置虚引用的唯一目的就是能在这个对象被回收的时候收到一个系统通知。虚引用主要用于检测对象是否已经从内存中删除

## 12. 垃圾回收算法

**1.标记清除算法**

先标记，标记完成后统一回收。缺点是两个过程效率都不高，而且会产生内存碎片

**2.复制算法（新生代）**

把内存分为2部分，一次只用其中的一半，垃圾回收时会把存活的对象复制到另一块上，再对之前那一半进行清理

**3.标记整理算法（不适合老年代）**

老年代回收策略标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，不生成碎片 

## 13. 几种垃圾收集器

1.java -XX:+PrintCommandLineFlags -version 查看程序使用的默认JVM参数，下面是jdk1.8默认采用的垃圾收集器

**Parallel Scavenge收集器（新生代）**

Parallel Scavenge 收集器是一个新生代收集器，采用复制算法，并且是多线程收集器.Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量。这里所谓的吞吐量是指CPU用于运行用户代码的时间与CPU总消耗时间的比值,吞吐量 = 运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间)。Parallel Scavenge 收集器有两个参数用于精确控制吞吐量
**控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis**参数允许的值是一个大于0的毫秒数，收集器将尽可能地保证内存回收花费的时间不超过设定值
**直接设置吞吐量大小的-XX:GCTimeRatio参数**（参数的值是一个大于0且小于100的整数，也就是垃圾收集时间占总时间的比率，相当于是1-吞吐量。如果把此参数设置为99，就是允许最大1%（既 1 /（1 + 99））的垃圾收集时间）
**-XX:+UseAdaptiveSizePolicy**是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量

**Serial Old收集器**（老年代）

Serial Old是 Serial收集器的老年代版本；针对老年代；采用"标记-整理"算法；单线程收集；进行垃圾收集时，必须暂停所有工作线程，直到完成；即会"Stop The World"；

**1.CMS（Concurrent Mark Sweep）**收集器是一种以获取最短回收停顿时间为目标的收集器，是基于“标记-清除”算法实现的。CMS收集器工作的整个流程分为以下4个步骤：

**初始标记**：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要“Stop The World”。

**并发标记**：进行GC Roots Tracing的过程，在整个过程中耗时最长。

**重新标记**：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。此阶段也需要“Stop The World”。

**并发清除**：由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作。所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。

**2.G1收集器**

G1在使用时，Java堆的内存布局与其他收集器有很大区别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，而都是一部分Region（不需要连续）的集合。G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的来由）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。