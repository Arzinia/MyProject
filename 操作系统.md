# 操作系统

## 1. 中断

程序执行过程中，遇到急需处理的事件时，暂时中止CPU上现行程序的运行，转去执行相应的事件处理程序，待处理完成后再返回原程序被中断处或调度其他程序执行

## 2. 硬中断和软中断的区别

1、软中断是执行中断指令产生的，而硬中断是由外设引发的

2、硬中断的中断号是由中断控制器提供的，软中断的中断号由指令直接指出，无需使用中断控制器

3、硬中断是可屏蔽的，软中断不可屏蔽

## 3. 进程的内存分布

1.一个可执行的程序（程序段TEXT）

2.程序执行需要的相关数据（变量，工作空间，缓冲区等）

初始化过的数据(Data): 在程序运行初已经对变量进行初始化的数据

未初始化过的数据(BSS): 在程序运行初未对变量进行初始化的数据

栈 (Stack): 存储局部、临时变量，函数调用时，存储函数的返回指针，用于控制函数的调用和返回。在程序块开始时自动分配内存,结束时自动释放内存，其操作方式类似于数据结构中的栈

堆 (Heap): 存储动态内存分配,需要程序员手工分配,手工释放.注意它与数据结构中的堆是两回事，分配方式类似于链表

3.程序执行的上下文

## 4. 进程线程的区别

进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的 实时性，实现进程内部的并发；一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在；进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存

## 5. fork函数

该函数的特点是调用一次，返回两次，一次是在父进程，一次是在子进程。两次返回的区别是子进程的返回值为0，父进程的返回值是新子进程的ID

1.fork之后父子进程将共享代码文本段，但是各自拥有不同的栈段、数据段及堆段拷贝。子进程的栈、数据从fork一瞬间开始是对于父进程的完全拷贝、每个进程可以更改自己的数据，而不要担心相互影响

2.fork之后父子进程同时开始从fork点向下执行代码，具体fork之后CPU会调度到谁？不一定！

3.执行fork之后，子进程将拷贝父进程的文件描述符副本，指向同一个文件句柄（包含了当前文件读写的偏移量等信息）

clone函数：Fork的底层其实就是调用的clone，可以选择clone父进程的一部分

## 6. vfork函数

![Image text](https://github.com/Arzinia/MyProject/blob/master/images/vfork%E5%92%8Cfork%E5%87%BD%E6%95%B0.png)

## 7. 僵尸进程及处理方法

僵尸进程是当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进程。子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。这是每个子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免

![Image text](https://github.com/Arzinia/MyProject/blob/master/images/%E9%81%BF%E5%85%8D%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B.png)

wait函数功能：

1）阻塞等待子进程退出

2）回收子进程残余资源

3）获取子进程结束状态

函数返回值：成功：清理掉的子进程id,失败：返回-1；waitpid函数功能：作用同wait，但可以指定pid进程清理，可以不阻塞

## 8. 孤儿进程

一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程