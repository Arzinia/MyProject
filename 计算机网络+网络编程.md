# 计算机网络+网络编程

## 1. TCP首部

![Image text](https://github.com/Arzinia/MyProject/blob/master/images/TCP%E9%A6%96%E9%83%A8.png)

## 2. 三次握手

![Image text](https://github.com/Arzinia/MyProject/blob/master/images/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)

1、client发送SYN到server，将状态修改为SYN_SEND，如果server收到请求，则将状态修改为SYN_RCVD，并把该请求放到syns queue队列中

2、server回复SYN+ACK给client，如果client收到请求，则将状态修改为ESTABLISHED，并发送ACK给server

3、server收到ACK，将状态修改为ESTABLISHED，并把该请求从syns queue中放到accept queue

在linux系统内核中维护了两个队列：syns queue和accept queue

（1）服务端只处理指定来源IP的TCP连接请求，其它未指定来源的连接请求一概拒绝

（2）缩短服务端的等待时间

## 3. 四次挥手

![Image text](https://github.com/Arzinia/MyProject/blob/master/images/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)

1. A向B发送一个FIN标志为1的报文

2. B接收到这个FIN报文，回复一个ACK，进入CLOSE_WAIT状态，等待断开接收方的连接，此时B可以继续发送报文

3. A接收到ACK，处于半关闭状态，但是还是可以接收

4. B的应用层决定断开连接，此时B向A发送FIN

5. A接收到FIN ，回复一个ACK，进入TIME_WAIT，持续2个MSL (1~4分钟)后才能进入CLOSED状态

6. B接收到ACK，立刻进入CLOSED状态

   

为什么要等两个MSL？

1.最后一个ACK可能会丢失，如果ACK丢失了，B会超时重传FIN的，如果A接收到这个重传的FIN，则又会发一次ACK，并重新计时两个MSL

2.等待这次连接的所有报文都消失在网络里，防止已经失效的请求出现引起不必要的错误

## 4. TCP和UDP的区别

1、TCP面向连接，发送之前需要先建立连接；UDP是无连接的，即发送数据之前不需要建立连接

2、TCP提供可靠的服务，数据无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，即不保证可靠交付

3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流，会把字节流切分成窗口大小；UDP是面向报文,给多少发多少

4、UDP没有拥塞控制，和流量控制。因此网络出现拥塞不会使源主机的发送速率降低

5、每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信

6、TCP首部开销20字节;UDP的首部开销小，只有8个字节

1:面向报文

面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这也就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文

2.面向字节流

TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去

## 5. TCP可靠性保证

